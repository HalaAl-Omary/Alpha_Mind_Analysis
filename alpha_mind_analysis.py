# -*- coding: utf-8 -*-
"""Alpha_mind_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tGefjktLk1I_PEx4Tnu8wH91h8yFuG-w

# Environnement Setup On Google Colab
"""

# 1.1 Install Dependencies Correctly
!pip install -q torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
!pip install -q transformers sentence-transformers faiss-cpu chromadb langchain openai yfinance
!pip install -q pandas numpy plotly dash scikit-learn seaborn
!pip install -q streamlit pyngrok ta
!pip install -q newsapi-python alpha_vantage

print("‚úÖ All dependencies installed successfully!")

# 1.2 Import Libraries
import os
import sys
import json
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

print("‚úÖ Libraries imported!")

# 1.3 Create project structure locally (no Google Drive)
project_path = '/content/FinSight_AI'
os.makedirs(project_path, exist_ok=True)
os.makedirs(f'{project_path}/data', exist_ok=True)
os.makedirs(f'{project_path}/models', exist_ok=True)
os.makedirs(f'{project_path}/cache', exist_ok=True)

print(f"‚úÖ Project structure created at: {project_path}")

"""# Enhanced Data Collection Module"""

!pip install pandas-market-calendars

# 2.1 Advanced Financial Data Collector
import yfinance as yf
import requests
from bs4 import BeautifulSoup
import pandas_market_calendars as mcal
from alpha_vantage.timeseries import TimeSeries

class EnhancedFinancialDataCollector:
    """Advanced data collection with multiple sources"""

    def __init__(self, api_keys=None):
        self.api_keys = api_keys or {}
        self.cache_dir = f'{project_path}/cache'

    def get_market_data(self, symbol, period='6mo', interval='1d'):
        """Get comprehensive market data"""
        try:
            ticker = yf.Ticker(symbol)

            # Historical data
            hist = ticker.history(period=period, interval=interval)

            # Options data
            try:
                options = ticker.options
                if options:
                    options_data = {}
                    for date in options[:2]:  # Get nearest two expirations
                        calls = ticker.option_chain(date).calls
                        puts = ticker.option_chain(date).puts
                        options_data[date] = {'calls': calls, 'puts': puts}
            except:
                options_data = None

            # Company info
            info = ticker.info

            # Analyst recommendations
            recommendations = ticker.recommendations

            # Institutional holders
            institutional = ticker.institutional_holders

            return {
                'historical': hist,
                'options': options_data,
                'info': info,
                'recommendations': recommendations,
                'institutional_holders': institutional,
                'symbol': symbol,
                'timestamp': datetime.now()
            }

        except Exception as e:
            print(f"Error fetching data for {symbol}: {str(e)}")
            return None

    def get_live_news(self, symbol, max_articles=20):
        """Fetch real financial news"""
        # For demo, we'll use simulated data
        # In production: NewsAPI, Bloomberg, Reuters APIs

        sample_news = [
            {
                'title': f'{symbol} Surpasses Q4 Earnings Expectations',
                'content': f'{symbol} reported Q4 earnings of $2.50 per share, beating estimates of $2.30. Revenue grew 15% YoY.',
                'sentiment': 'positive',
                'confidence': 0.85,
                'source': 'Bloomberg',
                'date': datetime.now().strftime('%Y-%m-%d %H:%M'),
                'impact_score': 0.8,
                'tags': ['earnings', 'beat', 'growth']
            },
            {
                'title': f'Analysts Upgrade {symbol} to "Strong Buy"',
                'content': f'Goldman Sachs upgrades {symbol} from "Buy" to "Strong Buy" with price target increase to $300.',
                'sentiment': 'positive',
                'confidence': 0.90,
                'source': 'Goldman Sachs',
                'date': (datetime.now() - timedelta(hours=2)).strftime('%Y-%m-%d %H:%M'),
                'impact_score': 0.7,
                'tags': ['upgrade', 'price_target', 'analyst']
            },
            {
                'title': f'{symbol} Faces Regulatory Investigation',
                'content': f'SEC launches investigation into {symbol}\'s accounting practices.',
                'sentiment': 'negative',
                'confidence': 0.75,
                'source': 'Reuters',
                'date': (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d %H:%M'),
                'impact_score': 0.9,
                'tags': ['regulatory', 'investigation', 'risk']
            },
            {
                'title': f'{symbol} Announces Major Acquisition',
                'content': f'{symbol} acquires TechStart Inc. for $5B to expand AI capabilities.',
                'sentiment': 'positive',
                'confidence': 0.80,
                'source': 'Wall Street Journal',
                'date': (datetime.now() - timedelta(days=2)).strftime('%Y-%m-%d %H:%M'),
                'impact_score': 0.6,
                'tags': ['acquisition', 'expansion', 'AI']
            }
        ]

        return sample_news[:max_articles]

    def get_social_sentiment(self, symbol):
        """Get social media sentiment (simulated for demo)"""
        # In production: Twitter API, Reddit API, StockTwits

        return {
            'twitter': {
                'mentions': np.random.randint(1000, 10000),
                'sentiment': np.random.uniform(0.4, 0.8),
                'top_hashtags': [f'#{symbol}', '#stocks', '#investing'],
                'influencers': ['@MarketWatch', '@CNBC', '@WSJ']
            },
            'reddit': {
                'mentions': np.random.randint(500, 5000),
                'sentiment': np.random.uniform(0.3, 0.7),
                'top_subreddits': ['r/stocks', 'r/investing', 'r/wallstreetbets'],
                'hot_posts': []
            }
        }

    def get_macro_data(self):
        """Get macroeconomic indicators"""
        indicators = {
            'vix': np.random.uniform(15, 25),  # Volatility index
            'usd_index': np.random.uniform(95, 105),
            'treasury_10y': np.random.uniform(3.5, 4.5),
            'inflation_rate': np.random.uniform(2.5, 3.5),
            'unemployment': np.random.uniform(3.5, 4.5),
            'gdp_growth': np.random.uniform(1.5, 2.5)
        }
        return indicators

"""# Advanced RAG System With Financial LLM"""

# 3.1 Enhanced Financial RAG System
from sentence_transformers import SentenceTransformer
import chromadb
from chromadb.config import Settings
import faiss
import pickle

class FinancialRAGSystem:
    """Advanced RAG system for financial analysis"""

    def __init__(self, model_name='all-MiniLM-L6-v2'):
        self.embedding_model = SentenceTransformer(model_name)
        self.chroma_client = chromadb.Client(Settings(
            chroma_db_impl="duckdb+parquet",
            persist_directory=f"{project_path}/chroma_db"
        ))

        # Financial knowledge base
        self.financial_terms = self._load_financial_knowledge()
        self.company_profiles = {}

    def _load_financial_knowledge(self):
        """Load comprehensive financial knowledge base"""
        financial_knowledge = [
            {
                "id": "market_terms_1",
                "content": """
                Bull Market: Period of rising stock prices, typically 20%+ from recent lows.
                Characteristics: Investor optimism, economic growth, high trading volume.
                Indicators: Moving averages trending up, RSI between 50-70, high put/call ratio.
                """,
                "metadata": {"type": "market_term", "category": "basic"}
            },
            {
                "id": "market_terms_2",
                "content": """
                Bear Market: Period of falling stock prices, typically 20%+ from recent highs.
                Characteristics: Investor pessimism, economic contraction, low trading volume.
                Indicators: Moving averages trending down, RSI below 30, low put/call ratio.
                """,
                "metadata": {"type": "market_term", "category": "basic"}
            },
            {
                "id": "technical_indicators",
                "content": """
                Technical Analysis Indicators:
                1. RSI (Relative Strength Index): Momentum oscillator, 30=oversold, 70=overbought.
                2. MACD (Moving Average Convergence Divergence): Trend-following momentum.
                3. Bollinger Bands: Volatility bands around moving average.
                4. Moving Averages: SMA (Simple), EMA (Exponential).
                5. Volume Analysis: Confirm price movements.
                """,
                "metadata": {"type": "technical_analysis", "category": "intermediate"}
            },
            {
                "id": "sentiment_analysis",
                "content": """
                Financial Sentiment Analysis Factors:
                1. Earnings Reports: EPS beats/misses, revenue growth, guidance.
                2. Analyst Actions: Upgrades/downgrades, price target changes.
                3. News Sentiment: Tone of financial news articles.
                4. Social Media: Twitter/Reddit sentiment, discussion volume.
                5. Options Flow: Unusual options activity, put/call ratios.
                """,
                "metadata": {"type": "sentiment", "category": "advanced"}
            }
        ]
        return financial_knowledge

    def create_vector_store(self):
        """Create and populate vector database"""
        try:
            # Create collection
            collection = self.chroma_client.create_collection(
                name="financial_knowledge",
                metadata={"description": "Financial analysis knowledge base"}
            )

            # Add documents
            for doc in self.financial_terms:
                embedding = self.embedding_model.encode(doc["content"]).tolist()
                collection.add(
                    embeddings=[embedding],
                    documents=[doc["content"]],
                    metadatas=[doc["metadata"]],
                    ids=[doc["id"]]
                )

            print(f"‚úÖ Vector store created with {len(self.financial_terms)} documents")
            return collection

        except Exception as e:
            print(f"Error creating vector store: {str(e)}")
            return None

    def retrieve_context(self, query, n_results=5):
        """Retrieve relevant financial context"""
        try:
            collection = self.chroma_client.get_collection("financial_knowledge")
            query_embedding = self.embedding_model.encode(query).tolist()

            results = collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results
            )

            context = "\n\n".join(results['documents'][0]) if results['documents'] else ""
            return context

        except Exception as e:
            print(f"Error retrieving context: {str(e)}")
            return ""

    def analyze_company(self, symbol, company_name):
        """Comprehensive company analysis using RAG"""
        # Retrieve financial context
        context = self.retrieve_context(f"analyze {company_name} stock performance")

        # Generate analysis
        analysis_prompt = f"""
        Based on financial knowledge and {company_name} ({symbol}) data:

        Context: {context}

        Please provide analysis covering:
        1. Market Position & Competitive Advantage
        2. Financial Health Metrics
        3. Growth Prospects
        4. Risk Factors
        5. Investment Recommendation

        Analysis:
        """

        # In production, this would call an LLM API
        # For demo, return structured analysis
        return {
            "company": company_name,
            "symbol": symbol,
            "analysis_timestamp": datetime.now().strftime('%Y-%m-%d %H:%M'),
            "market_position": "Strong competitive moat in technology sector",
            "financial_health": "Excellent balance sheet with low debt",
            "growth_prospects": "High growth potential in AI and services",
            "risk_factors": ["Regulatory scrutiny", "Market competition"],
            "recommendation": "BUY",
            "confidence_score": 0.82
        }

"""# Advanced Sentiment Analysis With Deep Learning"""

# 4.1 Deep Learning Sentiment Analyzer
import torch
import torch.nn as nn
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier

class AdvancedSentimentAnalyzer:
    """Multi-model sentiment analysis for finance"""

    def __init__(self):
        # Financial-specific keywords
        self.financial_lexicon = {
            'positive': [
                'beat', 'surge', 'rally', 'soar', 'jump', 'gain', 'profit',
                'growth', 'strong', 'bullish', 'upgrade', 'outperform',
                'record', 'breakthrough', 'innovation', 'dividend', 'buyback'
            ],
            'negative': [
                'miss', 'plunge', 'slump', 'drop', 'fall', 'loss', 'decline',
                'weak', 'bearish', 'downgrade', 'underperform', 'investigation',
                'lawsuit', 'regulatory', 'risk', 'concern', 'volatility'
            ],
            'uncertainty': [
                'uncertain', 'volatile', 'unclear', 'ambiguous', 'mixed',
                'neutral', 'wait', 'see', 'monitor', 'evaluate'
            ]
        }

        # Initialize deep learning model (simplified for demo)
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

    def analyze_text(self, text):
        """Comprehensive sentiment analysis"""
        results = {
            'lexicon_score': self._lexicon_analysis(text),
            'deep_learning_score': self._deep_learning_analysis(text),
            'financial_context': self._extract_financial_context(text),
            'confidence': 0.0,
            'final_sentiment': 'neutral',
            'impact_score': 0.5
        }

        # Combine scores
        lexicon_weight = 0.3
        dl_weight = 0.7

        combined_score = (results['lexicon_score'] * lexicon_weight +
                         results['deep_learning_score'] * dl_weight)

        # Determine sentiment
        if combined_score >= 0.6:
            results['final_sentiment'] = 'positive'
            results['impact_score'] = combined_score
        elif combined_score <= 0.4:
            results['final_sentiment'] = 'negative'
            results['impact_score'] = 1 - combined_score
        else:
            results['final_sentiment'] = 'neutral'
            results['impact_score'] = 0.5

        results['confidence'] = abs(combined_score - 0.5) * 2
        results['combined_score'] = combined_score

        return results

    def _lexicon_analysis(self, text):
        """Rule-based financial lexicon analysis"""
        text_lower = text.lower()

        positive_count = sum(1 for word in self.financial_lexicon['positive']
                           if word in text_lower)
        negative_count = sum(1 for word in self.financial_lexicon['negative']
                           if word in text_lower)

        total = positive_count + negative_count
        if total > 0:
            return positive_count / total
        return 0.5

    def _deep_learning_analysis(self, text):
        """Deep learning-based analysis (simulated for demo)"""
        # In production: Use fine-tuned financial BERT
        # For demo: Simulate with pattern recognition
        positive_patterns = ['beat', 'strong', 'growth', 'profit']
        negative_patterns = ['miss', 'weak', 'loss', 'decline']

        score = 0.5

        for pattern in positive_patterns:
            if pattern in text.lower():
                score += 0.1

        for pattern in negative_patterns:
            if pattern in text.lower():
                score -= 0.1

        return max(0, min(1, score))

    def _extract_financial_context(self, text):
        """Extract financial context from text"""
        context = {
            'mentions_earnings': 'earnings' in text.lower(),
            'mentions_revenue': 'revenue' in text.lower(),
            'mentions_guidance': 'guidance' in text.lower(),
            'mentions_dividend': 'dividend' in text.lower(),
            'mentions_acquisition': any(word in text.lower()
                                      for word in ['acquisition', 'merger', 'buy'])
        }
        return context

    def batch_analyze(self, texts):
        """Analyze multiple texts"""
        return [self.analyze_text(text) for text in texts]

"""  # Technical Analysis Engine"""

# 5.1 Advanced Technical Analysis
import ta
import pandas as pd
import numpy as np

class TechnicalAnalysisEngine:
    """Comprehensive technical analysis"""

    def __init__(self):
        self.indicators = {}

    def calculate_indicators(self, price_data):
        """Calculate all technical indicators"""
        if price_data is None or len(price_data) < 50:
            return None

        df = price_data.copy()

        # Trend Indicators
        df['SMA_20'] = ta.trend.sma_indicator(df['Close'], window=20)
        df['SMA_50'] = ta.trend.sma_indicator(df['Close'], window=50)
        df['EMA_12'] = ta.trend.ema_indicator(df['Close'], window=12)
        df['EMA_26'] = ta.trend.ema_indicator(df['Close'], window=26)

        # Momentum Indicators
        df['RSI'] = ta.momentum.rsi(df['Close'], window=14)
        df['MACD'] = ta.trend.macd(df['Close'])
        df['Stochastic'] = ta.momentum.stoch(df['High'], df['Low'], df['Close'])

        # Volatility Indicators
        df['BB_upper'], df['BB_middle'], df['BB_lower'] = ta.volatility.bollinger_hband_indicator(
            df['Close'], window=20, window_dev=2), \
            ta.volatility.bollinger_mavg(df['Close'], window=20), \
            ta.volatility.bollinger_lband_indicator(df['Close'], window=20, window_dev=2)

        # Volume Indicators
        df['OBV'] = ta.volume.on_balance_volume(df['Close'], df['Volume'])
        df['Volume_SMA'] = ta.volume.volume_weighted_average_price(
            df['High'], df['Low'], df['Close'], df['Volume'], window=20)

        # Support/Resistance
        df['Support'] = df['Close'].rolling(20).min()
        df['Resistance'] = df['Close'].rolling(20).max()

        # Generate signals
        signals = self._generate_signals(df)

        return {
            'dataframe': df,
            'signals': signals,
            'summary': self._create_summary(df),
            'latest_values': self._get_latest_values(df)
        }

    def _generate_signals(self, df):
        """Generate trading signals from indicators"""
        signals = {
            'trend': self._analyze_trend(df),
            'momentum': self._analyze_momentum(df),
            'volatility': self._analyze_volatility(df),
            'volume': self._analyze_volume(df),
            'overall_signal': 'NEUTRAL',
            'confidence': 0.5
        }

        # Combine signals
        signal_score = 0
        weights = {'trend': 0.3, 'momentum': 0.3, 'volatility': 0.2, 'volume': 0.2}

        for signal_type in ['trend', 'momentum', 'volatility', 'volume']:
            if signals[signal_type] == 'BULLISH':
                signal_score += weights[signal_type]
            elif signals[signal_type] == 'BEARISH':
                signal_score -= weights[signal_type]

        # Determine overall signal
        if signal_score >= 0.3:
            signals['overall_signal'] = 'BULLISH'
            signals['confidence'] = signal_score
        elif signal_score <= -0.3:
            signals['overall_signal'] = 'BEARISH'
            signals['confidence'] = -signal_score
        else:
            signals['overall_signal'] = 'NEUTRAL'
            signals['confidence'] = 0.5

        return signals

    def _analyze_trend(self, df):
        """Analyze trend indicators"""
        if len(df) < 50:
            return 'NEUTRAL'

        price = df['Close'].iloc[-1]
        sma_20 = df['SMA_20'].iloc[-1]
        sma_50 = df['SMA_50'].iloc[-1]

        if price > sma_20 > sma_50:
            return 'BULLISH'
        elif price < sma_20 < sma_50:
            return 'BEARISH'
        return 'NEUTRAL'

    def _analyze_momentum(self, df):
        """Analyze momentum indicators"""
        rsi = df['RSI'].iloc[-1]
        macd = df['MACD'].iloc[-1]

        if rsi < 30 and macd > 0:
            return 'BULLISH'
        elif rsi > 70 and macd < 0:
            return 'BEARISH'
        return 'NEUTRAL'

    def _analyze_volatility(self, df):
        """Analyze volatility"""
        if len(df) < 20:
            return 'NEUTRAL'

        current = df['Close'].iloc[-1]
        bb_upper = df['BB_upper'].iloc[-1]
        bb_lower = df['BB_lower'].iloc[-1]

        if current < bb_lower:
            return 'BULLISH'  # Oversold
        elif current > bb_upper:
            return 'BEARISH'  # Overbought
        return 'NEUTRAL'

    def _analyze_volume(self, df):
        """Analyze volume"""
        if len(df) < 20:
            return 'NEUTRAL'

        obv = df['OBV'].iloc[-1]
        obv_sma = df['OBV'].rolling(20).mean().iloc[-1]

        if obv > obv_sma:
            return 'BULLISH'
        elif obv < obv_sma:
            return 'BEARISH'
        return 'NEUTRAL'

    def _create_summary(self, df):
        """Create technical analysis summary"""
        return {
            'price_trend': 'Up' if df['Close'].iloc[-1] > df['Close'].iloc[-20] else 'Down',
            'volatility': df['Close'].pct_change().std() * np.sqrt(252),
            'rsi_status': 'Oversold' if df['RSI'].iloc[-1] < 30 else
                         'Overbought' if df['RSI'].iloc[-1] > 70 else 'Neutral',
            'support_level': df['Support'].iloc[-1],
            'resistance_level': df['Resistance'].iloc[-1]
        }

    def _get_latest_values(self, df):
        """Get latest indicator values"""
        return {
            'price': df['Close'].iloc[-1],
            'rsi': df['RSI'].iloc[-1],
            'macd': df['MACD'].iloc[-1],
            'bb_position': (df['Close'].iloc[-1] - df['BB_lower'].iloc[-1]) /
                          (df['BB_upper'].iloc[-1] - df['BB_lower'].iloc[-1]) * 100
        }

""" # Frontend Interface With Streamlit"""

# Commented out IPython magic to ensure Python compatibility.
# # 6.1 Streamlit Frontend Setup
# %%writefile /content/finsight_dashboard.py
# 
# import streamlit as st
# import plotly.graph_objects as go
# import plotly.express as px
# import pandas as pd
# import numpy as np
# from datetime import datetime, timedelta
# import yfinance as yf
# 
# # Page configuration
# st.set_page_config(
#     page_title="FinSight AI - Advanced Market Analysis",
#     page_icon="üìà",
#     layout="wide",
#     initial_sidebar_state="expanded"
# )
# 
# # Custom CSS
# st.markdown("""
# <style>
#     .main-header {
#         font-size: 2.5rem;
#         color: #1E3A8A;
#         text-align: center;
#         margin-bottom: 2rem;
#     }
#     .metric-card {
#         background-color: #f8f9fa;
#         padding: 1.5rem;
#         border-radius: 10px;
#         border-left: 5px solid #1E3A8A;
#         margin-bottom: 1rem;
#     }
#     .positive {
#         color: #10B981;
#         font-weight: bold;
#     }
#     .negative {
#         color: #EF4444;
#         font-weight: bold;
#     }
#     .neutral {
#         color: #6B7280;
#         font-weight: bold;
#     }
# </style>
# """, unsafe_allow_html=True)
# 
# class FinSightDashboard:
#     """Interactive dashboard for FinSight AI"""
# 
#     def __init__(self):
#         self.symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'JPM', 'V', 'JNJ']
# 
#     def run(self):
#         """Run the dashboard"""
#         # Sidebar
#         with st.sidebar:
#             st.image("https://img.icons8.com/color/96/000000/stock-share.png", width=100)
#             st.title("FinSight AI")
#             st.markdown("---")
# 
#             # Symbol selection
#             selected_symbol = st.selectbox(
#                 "Select Stock Symbol",
#                 self.symbols,
#                 index=0
#             )
# 
#             # Analysis type
#             analysis_type = st.selectbox(
#                 "Analysis Type",
#                 ["Comprehensive", "Technical", "Sentiment", "Fundamental"],
#                 index=0
#             )
# 
#             # Timeframe
#             timeframe = st.select_slider(
#                 "Timeframe",
#                 options=["1D", "1W", "1M", "3M", "6M", "1Y", "5Y"],
#                 value="6M"
#             )
# 
#             # Additional settings
#             st.markdown("---")
#             st.subheader("Settings")
#             show_advanced = st.checkbox("Show Advanced Metrics", value=True)
#             auto_refresh = st.checkbox("Auto-refresh", value=True)
# 
#             if st.button("üîÑ Refresh Analysis"):
#                 st.rerun()
# 
#         # Main content
#         st.markdown('<h1 class="main-header">üìà FinSight AI Dashboard</h1>', unsafe_allow_html=True)
# 
#         # Top metrics row
#         col1, col2, col3, col4 = st.columns(4)
# 
#         with col1:
#             self.display_metric_card(
#                 title="Current Price",
#                 value="$175.42",
#                 change="+2.34%",
#                 change_type="positive"
#             )
# 
#         with col2:
#             self.display_metric_card(
#                 title="Market Sentiment",
#                 value="Bullish",
#                 change="High Confidence",
#                 change_type="positive"
#             )
# 
#         with col3:
#             self.display_metric_card(
#                 title="RSI",
#                 value="62.5",
#                 change="Neutral",
#                 change_type="neutral"
#             )
# 
#         with col4:
#             self.display_metric_card(
#                 title="Volume",
#                 value="45.2M",
#                 change="Above Average",
#                 change_type="positive"
#             )
# 
#         # Charts section
#         st.markdown("---")
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             st.subheader("Price Chart")
#             self.plot_price_chart(selected_symbol, timeframe)
# 
#         with col2:
#             st.subheader("Sentiment Analysis")
#             self.plot_sentiment_gauge()
# 
#         # Detailed analysis
#         st.markdown("---")
# 
#         tab1, tab2, tab3, tab4 = st.tabs(["üìä Technical", "üòä Sentiment", "üèõÔ∏è Fundamental", "üì∞ News"])
# 
#         with tab1:
#             self.display_technical_analysis()
# 
#         with tab2:
#             self.display_sentiment_analysis()
# 
#         with tab3:
#             self.display_fundamental_analysis()
# 
#         with tab4:
#             self.display_news_feed()
# 
#         # Trading signals
#         st.markdown("---")
#         self.display_trading_signals()
# 
#     def display_metric_card(self, title, value, change, change_type):
#         """Display a metric card"""
#         st.markdown(f"""
#         <div class="metric-card">
#             <h4>{title}</h4>
#             <h2>{value}</h2>
#             <p class="{change_type}">{change}</p>
#         </div>
#         """, unsafe_allow_html=True)
# 
#     def plot_price_chart(self, symbol, timeframe):
#         """Plot interactive price chart"""
#         # Get data
#         period_map = {"1D": "1d", "1W": "5d", "1M": "1mo", "3M": "3mo",
#                      "6M": "6mo", "1Y": "1y", "5Y": "5y"}
# 
#         data = yf.download(symbol, period=period_map[timeframe])
# 
#         # Create chart
#         fig = go.Figure()
# 
#         # Candlestick chart
#         fig.add_trace(go.Candlestick(
#             x=data.index,
#             open=data['Open'],
#             high=data['High'],
#             low=data['Low'],
#             close=data['Close'],
#             name="Price"
#         ))
# 
#         # Moving averages
#         fig.add_trace(go.Scatter(
#             x=data.index,
#             y=data['Close'].rolling(20).mean(),
#             name="SMA 20",
#             line=dict(color='orange', width=2)
#         ))
# 
#         fig.add_trace(go.Scatter(
#             x=data.index,
#             y=data['Close'].rolling(50).mean(),
#             name="SMA 50",
#             line=dict(color='red', width=2)
#         ))
# 
#         fig.update_layout(
#             title=f"{symbol} Price Chart",
#             yaxis_title="Price ($)",
#             xaxis_title="Date",
#             height=400,
#             showlegend=True,
#             template="plotly_dark"
#         )
# 
#         st.plotly_chart(fig, use_container_width=True)
# 
#     def plot_sentiment_gauge(self):
#         """Plot sentiment gauge chart"""
#         fig = go.Figure(go.Indicator(
#             mode="gauge+number+delta",
#             value=72.5,
#             domain={'x': [0, 1], 'y': [0, 1]},
#             title={'text': "Market Sentiment Score", 'font': {'size': 24}},
#             delta={'reference': 50, 'increasing': {'color': "green"}},
#             gauge={
#                 'axis': {'range': [0, 100], 'tickwidth': 1},
#                 'bar': {'color': "darkblue"},
#                 'bgcolor': "white",
#                 'borderwidth': 2,
#                 'bordercolor': "gray",
#                 'steps': [
#                     {'range': [0, 30], 'color': 'red'},
#                     {'range': [30, 70], 'color': 'yellow'},
#                     {'range': [70, 100], 'color': 'green'}
#                 ],
#                 'threshold': {
#                     'line': {'color': "black", 'width': 4},
#                     'thickness': 0.75,
#                     'value': 72.5
#                 }
#             }
#         ))
# 
#         fig.update_layout(height=400)
#         st.plotly_chart(fig, use_container_width=True)
# 
#     def display_technical_analysis(self):
#         """Display technical analysis section"""
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             st.subheader("Key Indicators")
# 
#             indicators = {
#                 "RSI": {"value": 62.5, "status": "Neutral"},
#                 "MACD": {"value": 2.34, "status": "Bullish"},
#                 "Bollinger %B": {"value": 0.68, "status": "Neutral"},
#                 "Volume Trend": {"value": "‚Üë", "status": "Bullish"}
#             }
# 
#             for indicator, data in indicators.items():
#                 st.metric(label=indicator, value=data["value"], delta=data["status"])
# 
#         with col2:
#             st.subheader("Trend Analysis")
# 
#             # Trend indicators
#             trends = {
#                 "Short-term": "Bullish",
#                 "Medium-term": "Bullish",
#                 "Long-term": "Neutral",
#                 "Overall": "Bullish"
#             }
# 
#             for trend, direction in trends.items():
#                 color = "green" if "Bullish" in direction else "red" if "Bearish" in direction else "gray"
#                 st.markdown(f"**{trest}:** <span style='color:{color}'>{direction}</span>",
#                           unsafe_allow_html=True)
# 
#     def display_sentiment_analysis(self):
#         """Display sentiment analysis section"""
#         # Sentiment distribution
#         sentiment_data = pd.DataFrame({
#             'Source': ['News', 'Social', 'Analysts', 'Options'],
#             'Sentiment': [0.75, 0.62, 0.80, 0.55],
#             'Volume': [100, 85, 60, 40]
#         })
# 
#         fig = px.bar(sentiment_data, x='Source', y='Sentiment',
#                      color='Sentiment', title="Sentiment by Source",
#                      color_continuous_scale=['red', 'yellow', 'green'])
# 
#         st.plotly_chart(fig, use_container_width=True)
# 
#         # Sentiment timeline
#         st.subheader("Sentiment Timeline")
#         dates = pd.date_range(end=datetime.now(), periods=30, freq='D')
#         timeline_data = pd.DataFrame({
#             'Date': dates,
#             'Sentiment': np.random.uniform(0.4, 0.8, 30)
#         })
# 
#         fig_line = px.line(timeline_data, x='Date', y='Sentiment',
#                           title="30-Day Sentiment Trend")
#         st.plotly_chart(fig_line, use_container_width=True)
# 
#     def display_fundamental_analysis(self):
#         """Display fundamental analysis section"""
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             st.subheader("Financial Metrics")
# 
#             metrics = {
#                 "P/E Ratio": "28.5",
#                 "P/B Ratio": "8.2",
#                 "ROE": "45.2%",
#                 "Debt/Equity": "0.35",
#                 "Dividend Yield": "0.6%"
#             }
# 
#             for metric, value in metrics.items():
#                 st.metric(label=metric, value=value)
# 
#         with col2:
#             st.subheader("Analyst Consensus")
# 
#             consensus = {
#                 "Strong Buy": 15,
#                 "Buy": 8,
#                 "Hold": 5,
#                 "Sell": 2,
#                 "Strong Sell": 1
#             }
# 
#             fig_pie = go.Figure(data=[go.Pie(
#                 labels=list(consensus.keys()),
#                 values=list(consensus.values()),
#                 hole=0.3,
#                 marker_colors=['#00FF00', '#90EE90', '#FFFF00', '#FFA500', '#FF0000']
#             )])
# 
#             fig_pie.update_layout(title="Analyst Recommendations")
#             st.plotly_chart(fig_pie, use_container_width=True)
# 
#     def display_

"""# Backend And Frontend"""

# ============ AlphaMind Analytics Backend  ============

import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import json
import asyncio
from typing import Dict, List, Optional
import warnings
warnings.filterwarnings('ignore')

# ============ Data Collection Functions ============

def get_stock_data(symbol: str, period: str = "6mo") -> Dict:
    """Get historical stock data"""
    try:
        ticker = yf.Ticker(symbol)
        hist = ticker.history(period=period)

        if hist.empty:
            return {"error": "No data found for symbol"}

        # Convert to JSON serializable format
        data = []
        for idx, row in hist.iterrows():
            data.append({
                "date": idx.strftime('%Y-%m-%d'),
                "open": float(row['Open']),
                "high": float(row['High']),
                "low": float(row['Low']),
                "close": float(row['Close']),
                "volume": int(row['Volume'])
            })

        # Calculate metrics
        latest_close = float(hist['Close'].iloc[-1])
        prev_close = float(hist['Close'].iloc[-2]) if len(hist) > 1 else latest_close
        change_pct = ((latest_close - prev_close) / prev_close * 100) if prev_close != 0 else 0

        return {
            "symbol": symbol,
            "period": period,
            "data": data[-90:],  # Last 90 days
            "current_price": latest_close,
            "change_percent": round(change_pct, 2),
            "data_points": len(data),
            "success": True
        }

    except Exception as e:
        return {"error": str(e), "success": False}

def technical_analysis(symbol: str, period: str = "6mo") -> Dict:
    """Perform technical analysis"""
    try:
        ticker = yf.Ticker(symbol)
        hist = ticker.history(period=period)

        if len(hist) < 20:
            return {"error": "Insufficient data for analysis", "success": False}

        # Calculate indicators
        closes = hist['Close'].values

        # Moving averages
        sma_20 = pd.Series(closes).rolling(window=20).mean().iloc[-1]
        sma_50 = pd.Series(closes).rolling(window=50).mean().iloc[-1]

        # RSI
        delta = pd.Series(closes).diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain.iloc[-1] / loss.iloc[-1] if loss.iloc[-1] != 0 else 0
        rsi = 100 - (100 / (1 + rs))

        # MACD (simplified)
        exp1 = pd.Series(closes).ewm(span=12, adjust=False).mean()
        exp2 = pd.Series(closes).ewm(span=26, adjust=False).mean()
        macd = exp1.iloc[-1] - exp2.iloc[-1]

        # Determine signal
        current_price = closes[-1]
        signal = "NEUTRAL"

        if current_price > sma_20 > sma_50 and rsi < 70:
            signal = "BULLISH"
        elif current_price < sma_20 < sma_50 and rsi > 30:
            signal = "BEARISH"

        # Confidence score
        confidence = 0.5
        if signal == "BULLISH":
            confidence = 0.7 + (rsi / 200)
        elif signal == "BEARISH":
            confidence = 0.7 + ((100 - rsi) / 200)

        return {
            "symbol": symbol,
            "analysis": "technical",
            "indicators": {
                "price": round(float(current_price), 2),
                "sma_20": round(float(sma_20), 2),
                "sma_50": round(float(sma_50), 2),
                "rsi": round(float(rsi), 2),
                "macd": round(float(macd), 2),
                "signal": signal,
                "confidence": round(min(confidence, 0.95), 2)
            },
            "timestamp": datetime.now().isoformat(),
            "success": True
        }

    except Exception as e:
        return {"error": str(e), "success": False}

def sentiment_analysis(symbol: str) -> Dict:
    """Perform sentiment analysis (simulated for demo)"""
    try:
        # Consistent results per symbol
        np.random.seed(hash(symbol) % 1000)

        sentiment_sources = {
            "news_articles": {
                "score": np.random.uniform(0.6, 0.9),
                "count": np.random.randint(50, 200)
            },
            "social_media": {
                "score": np.random.uniform(0.4, 0.8),
                "count": np.random.randint(100, 1000)
            },
            "analyst_reports": {
                "score": np.random.uniform(0.7, 0.95),
                "count": np.random.randint(5, 20)
            },
            "options_flow": {
                "score": np.random.uniform(0.5, 0.85),
                "count": np.random.randint(100, 500)
            }
        }

        # Calculate weighted average
        weights = {
            "news_articles": 0.3,
            "social_media": 0.2,
            "analyst_reports": 0.3,
            "options_flow": 0.2
        }

        total_score = sum(sentiment_sources[src]["score"] * weights[src] for src in sentiment_sources)
        overall_sentiment = round(total_score, 3)

        # Sentiment label
        if overall_sentiment >= 0.7:
            label = "STRONGLY_BULLISH"
        elif overall_sentiment >= 0.6:
            label = "BULLISH"
        elif overall_sentiment <= 0.4:
            label = "BEARISH"
        elif overall_sentiment <= 0.3:
            label = "STRONGLY_BEARISH"
        else:
            label = "NEUTRAL"

        # Top keywords
        positive_keywords = ["growth", "profit", "innovation", "leadership", "strong", "beat", "upgrade", "record"]
        negative_keywords = ["risk", "competition", "regulation", "decline", "volatility", "miss", "downgrade", "concern"]

        np.random.shuffle(positive_keywords)
        np.random.shuffle(negative_keywords)

        keywords = positive_keywords[:3] + negative_keywords[:2]
        np.random.shuffle(keywords)

        return {
            "symbol": symbol,
            "analysis": "sentiment",
            "overall_score": overall_sentiment,
            "sentiment_label": label,
            "sources": sentiment_sources,
            "top_keywords": keywords[:5],
            "confidence": round(overall_sentiment, 2),
            "timestamp": datetime.now().isoformat(),
            "success": True
        }

    except Exception as e:
        return {"error": str(e), "success": False}

def fundamental_analysis(symbol: str) -> Dict:
    """Perform fundamental analysis"""
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info

        if not info:
            return {"error": "Company info not found", "success": False}

        # Extract key metrics
        metrics = {
            "valuation": {
                "market_cap": info.get("marketCap", 0),
                "pe_ratio": info.get("trailingPE", 0),
                "forward_pe": info.get("forwardPE", 0),
                "price_to_book": info.get("priceToBook", 0),
                "price_to_sales": info.get("priceToSalesTrailing12Months", 0)
            },
            "profitability": {
                "roe": info.get("returnOnEquity", 0),
                "roa": info.get("returnOnAssets", 0),
                "profit_margin": info.get("profitMargins", 0),
                "operating_margin": info.get("operatingMargins", 0)
            },
            "financial_health": {
                "debt_to_equity": info.get("debtToEquity", 0),
                "current_ratio": info.get("currentRatio", 0),
                "quick_ratio": info.get("quickRatio", 0)
            },
            "growth": {
                "revenue_growth": info.get("revenueGrowth", 0),
                "earnings_growth": info.get("earningsGrowth", 0)
            }
        }

        # Calculate overall health score
        health_score = 0.5  # Base score

        # Adjust based on metrics
        if metrics["profitability"]["roe"] > 0.15:
            health_score += 0.1
        if metrics["financial_health"]["debt_to_equity"] < 1:
            health_score += 0.1
        if metrics["valuation"]["pe_ratio"] and metrics["valuation"]["pe_ratio"] < 25:
            health_score += 0.05
        if metrics["growth"]["revenue_growth"] and metrics["growth"]["revenue_growth"] > 0.1:
            health_score += 0.1

        health_score = min(max(health_score, 0), 1)

        recommendation = "BUY" if health_score > 0.7 else "SELL" if health_score < 0.3 else "HOLD"

        return {
            "symbol": symbol,
            "analysis": "fundamental",
            "company_name": info.get("longName", symbol),
            "sector": info.get("sector", "Unknown"),
            "industry": info.get("industry", "Unknown"),
            "metrics": metrics,
            "health_score": round(health_score, 2),
            "recommendation": recommendation,
            "timestamp": datetime.now().isoformat(),
            "success": True
        }

    except Exception as e:
        return {"error": str(e), "success": False}

def comprehensive_analysis(symbol: str) -> Dict:
    """Comprehensive analysis combining all methods"""
    try:
        # Run all analyses
        technical = technical_analysis(symbol)
        sentiment = sentiment_analysis(symbol)
        fundamental = fundamental_analysis(symbol)

        if not all([technical.get("success"), sentiment.get("success"), fundamental.get("success")]):
            return {"error": "Failed to complete all analyses", "success": False}

        # Calculate overall score (weighted average)
        weights = {
            "technical": 0.4,
            "sentiment": 0.3,
            "fundamental": 0.3
        }

        technical_score = technical["indicators"]["confidence"]
        sentiment_score = sentiment["overall_score"]
        fundamental_score = fundamental["health_score"]

        overall_score = (
            technical_score * weights["technical"] +
            sentiment_score * weights["sentiment"] +
            fundamental_score * weights["fundamental"]
        )

        # Determine final recommendation
        if overall_score >= 0.7:
            recommendation = "STRONG_BUY"
            confidence = "HIGH"
        elif overall_score >= 0.6:
            recommendation = "BUY"
            confidence = "MEDIUM_HIGH"
        elif overall_score >= 0.5:
            recommendation = "HOLD"
            confidence = "MEDIUM"
        elif overall_score >= 0.4:
            recommendation = "SELL"
            confidence = "MEDIUM_LOW"
        else:
            recommendation = "STRONG_SELL"
            confidence = "HIGH"

        current_price = technical["indicators"]["price"]

        return {
            "symbol": symbol,
            "analysis": "comprehensive",
            "overall_score": round(overall_score, 3),
            "recommendation": recommendation,
            "confidence": confidence,
            "sub_analyses": {
                "technical": technical,
                "sentiment": sentiment,
                "fundamental": fundamental
            },
            "target_price": round(current_price * (1 + overall_score * 0.2), 2),
            "stop_loss": round(current_price * (1 - overall_score * 0.1), 2),
            "current_price": current_price,
            "timestamp": datetime.now().isoformat(),
            "success": True
        }

    except Exception as e:
        return {"error": str(e), "success": False}

def predict_price(symbol: str, days: int = 30) -> Dict:
    """Predict future prices (simulated ML)"""
    try:
        # Get current price
        ticker = yf.Ticker(symbol)
        hist = ticker.history(period="1mo")

        if hist.empty:
            return {"error": "No data for prediction", "success": False}

        current_price = float(hist['Close'].iloc[-1])

        # Simulate prediction using random walk with trend
        np.random.seed(hash(symbol) % 1000)

        predictions = []
        price = current_price

        for day in range(1, days + 1):
            # Add some trend based on recent performance
            if len(hist) > 5:
                recent_trend = (hist['Close'].iloc[-1] - hist['Close'].iloc[-5]) / hist['Close'].iloc[-5]
                trend_factor = 1 + recent_trend * 0.1
            else:
                trend_factor = 1

            # Random movement with volatility
            volatility = hist['Close'].pct_change().std() if len(hist) > 1 else 0.02
            daily_change = np.random.normal(0, volatility) * trend_factor

            price = price * (1 + daily_change)

            predictions.append({
                "day": day,
                "date": (datetime.now() + timedelta(days=day)).strftime('%Y-%m-%d'),
                "predicted_price": round(float(price), 2),
                "confidence": round(max(0.5, 1 - (day * 0.02)), 2)
            })

        # Calculate statistics
        predicted_prices = [p["predicted_price"] for p in predictions]

        return {
            "symbol": symbol,
            "current_price": round(current_price, 2),
            "predictions": predictions,
            "statistics": {
                "predicted_high": round(max(predicted_prices), 2),
                "predicted_low": round(min(predicted_prices), 2),
                "predicted_avg": round(np.mean(predicted_prices), 2),
                "expected_return": round(((predicted_prices[-1] / current_price) - 1) * 100, 2)
            },
            "timestamp": datetime.now().isoformat(),
            "success": True
        }

    except Exception as e:
        return {"error": str(e), "success": False}

def market_overview() -> Dict:
    """Get overall market data"""
    try:
        # Major indices
        indices = {
            "S&P 500": "^GSPC",
            "NASDAQ": "^IXIC",
            "Dow Jones": "^DJI",
            "VIX": "^VIX"
        }

        market_data = {}
        for name, symbol in indices.items():
            try:
                ticker = yf.Ticker(symbol)
                hist = ticker.history(period="5d")

                if not hist.empty:
                    latest = hist['Close'].iloc[-1]
                    prev = hist['Close'].iloc[-2] if len(hist) > 1 else latest
                    change_pct = ((latest - prev) / prev * 100) if prev != 0 else 0

                    market_data[name] = {
                        "symbol": symbol,
                        "price": round(float(latest), 2),
                        "change": round(float(latest - prev), 2),
                        "change_percent": round(float(change_pct), 2),
                        "volume": int(hist['Volume'].iloc[-1]) if 'Volume' in hist else 0
                    }
            except:
                continue

        # Market sentiment (simulated)
        market_sentiment = {
            "overall": np.random.uniform(0.4, 0.8),
            "fear_greed": np.random.randint(0, 100),
            "advancers": np.random.randint(1000, 3000),
            "decliners": np.random.randint(500, 2000),
            "put_call_ratio": round(np.random.uniform(0.5, 1.5), 2)
        }

        # Sector performance (simulated)
        sectors = ["Technology", "Healthcare", "Financials", "Energy", "Consumer", "Industrials"]
        sector_performance = {}

        for sector in sectors:
            sector_performance[sector] = {
                "performance": round(np.random.uniform(-3, 5), 2),
                "trend": "UP" if np.random.random() > 0.5 else "DOWN"
            }

        return {
            "market_data": market_data,
            "market_sentiment": market_sentiment,
            "sector_performance": sector_performance,
            "timestamp": datetime.now().isoformat(),
            "success": True
        }

    except Exception as e:
        return {"error": str(e), "success": False}

# ============ Test Functions ============

def test_all_functions():
    """Test all backend functions"""
    print("üß™ Testing AlphaMind Analytics Backend Functions...")
    print("=" * 60)

    # Test 1: Stock Data
    print("1. Testing Stock Data...")
    stock_data = get_stock_data("AAPL", "1mo")
    if stock_data.get("success"):
        print(f"   ‚úÖ Success! {stock_data['data_points']} data points")
        print(f"   üìà Current Price: ${stock_data['current_price']}")
        print(f"   üìä Change: {stock_data['change_percent']}%")
    else:
        print(f"   ‚ùå Error: {stock_data.get('error')}")

    print()

    # Test 2: Technical Analysis
    print("2. Testing Technical Analysis...")
    tech = technical_analysis("AAPL")
    if tech.get("success"):
        print(f"   ‚úÖ Success! Signal: {tech['indicators']['signal']}")
        print(f"   üìä RSI: {tech['indicators']['rsi']}")
        print(f"   üí™ Confidence: {tech['indicators']['confidence']*100:.1f}%")
    else:
        print(f"   ‚ùå Error: {tech.get('error')}")

    print()

    # Test 3: Sentiment Analysis
    print("3. Testing Sentiment Analysis...")
    sentiment = sentiment_analysis("AAPL")
    if sentiment.get("success"):
        print(f"   ‚úÖ Success! Sentiment: {sentiment['sentiment_label']}")
        print(f"   üìä Score: {sentiment['overall_score']*100:.1f}%")
        print(f"   üîë Keywords: {', '.join(sentiment['top_keywords'])}")
    else:
        print(f"   ‚ùå Error: {sentiment.get('error')}")

    print()

    # Test 4: Fundamental Analysis
    print("4. Testing Fundamental Analysis...")
    fundamental = fundamental_analysis("AAPL")
    if fundamental.get("success"):
        print(f"   ‚úÖ Success! Company: {fundamental['company_name']}")
        print(f"   üè¢ Sector: {fundamental['sector']}")
        print(f"   üìä Health Score: {fundamental['health_score']*100:.1f}%")
        print(f"   üéØ Recommendation: {fundamental['recommendation']}")
    else:
        print(f"   ‚ùå Error: {fundamental.get('error')}")

    print()

    # Test 5: Comprehensive Analysis
    print("5. Testing Comprehensive Analysis...")
    comprehensive = comprehensive_analysis("AAPL")
    if comprehensive.get("success"):
        print(f"   ‚úÖ Success! Overall Score: {comprehensive['overall_score']*100:.1f}%")
        print(f"   üéØ Recommendation: {comprehensive['recommendation']}")
        print(f"   üìà Target Price: ${comprehensive['target_price']}")
        print(f"   üõ°Ô∏è Stop Loss: ${comprehensive['stop_loss']}")
    else:
        print(f"   ‚ùå Error: {comprehensive.get('error')}")

    print()

    # Test 6: Predictions
    print("6. Testing Price Predictions...")
    predictions = predict_price("AAPL", 7)
    if predictions.get("success"):
        print(f"   ‚úÖ Success! Generated {len(predictions['predictions'])} predictions")
        print(f"   üìà Expected Return: {predictions['statistics']['expected_return']}%")
        print(f"   üìä Predicted High: ${predictions['statistics']['predicted_high']}")
    else:
        print(f"   ‚ùå Error: {predictions.get('error')}")

    print()

    # Test 7: Market Overview
    print("7. Testing Market Overview...")
    market = market_overview()
    if market.get("success"):
        print(f"   ‚úÖ Success! Market data for {len(market['market_data'])} indices")
        for name, data in market["market_data"].items():
            print(f"   üìä {name}: ${data['price']} ({data['change_percent']}%)")
    else:
        print(f"   ‚ùå Error: {market.get('error')}")

    print("=" * 60)
    print("‚úÖ All backend functions tested successfully!")

    return {
        "stock_data": stock_data,
        "technical": tech,
        "sentiment": sentiment,
        "fundamental": fundamental,
        "comprehensive": comprehensive,
        "predictions": predictions,
        "market": market
    }

# ============ Main Execution ============

if __name__ == "__main__":
    # Test the backend functions
    results = test_all_functions()

    print("\nüìä Sample Data Output:")
    print(json.dumps(results["comprehensive"], indent=2, default=str))

# Commented out IPython magic to ensure Python compatibility.
# 
# # ============ AlphaMind Analytics Frontend (Streamlit) ============
# 
# %%writefile /content/alphamind_frontend.py
# 
# import streamlit as st
# import plotly.graph_objects as go
# import plotly.express as px
# import pandas as pd
# import numpy as np
# import json
# from datetime import datetime, timedelta
# import warnings
# warnings.filterwarnings('ignore')
# 
# # ============ Page Configuration ============
# 
# st.set_page_config(
#     page_title="AlphaMind Analytics | MIT & Oxford",
#     page_icon="üìà",
#     layout="wide",
#     initial_sidebar_state="expanded"
# )
# 
# # ============ Custom CSS ============
# 
# st.markdown("""
# <style>
#     /* Main Styles */
#     .main-header {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         color: white;
#         padding: 3rem 2rem;
#         border-radius: 20px;
#         text-align: center;
#         margin-bottom: 2rem;
#         box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
#     }
# 
#     .university-badge {
#         display: inline-block;
#         background: rgba(255, 255, 255, 0.2);
#         padding: 10px 25px;
#         border-radius: 30px;
#         margin: 0 15px;
#         color: white;
#         font-weight: bold;
#         backdrop-filter: blur(10px);
#         border: 1px solid rgba(255, 255, 255, 0.3);
#     }
# 
#     .metric-card {
#         background: white;
#         padding: 1.5rem;
#         border-radius: 15px;
#         box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
#         margin: 0.5rem;
#         border-top: 4px solid;
#         transition: transform 0.3s ease;
#     }
# 
#     .metric-card:hover {
#         transform: translateY(-5px);
#     }
# 
#     .positive { color: #10B981; font-weight: bold; }
#     .negative { color: #EF4444; font-weight: bold; }
#     .neutral { color: #6B7280; font-weight: bold; }
# 
#     /* Custom Buttons */
#     .stButton > button {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         color: white;
#         border: none;
#         padding: 0.75rem 2rem;
#         border-radius: 10px;
#         font-weight: bold;
#         transition: all 0.3s ease;
#     }
# 
#     .stButton > button:hover {
#         transform: scale(1.05);
#         box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
#     }
# 
#     /* Tab Styling */
#     .stTabs [data-baseweb="tab-list"] {
#         gap: 8px;
#     }
# 
#     .stTabs [data-baseweb="tab"] {
#         border-radius: 10px 10px 0 0;
#         padding: 10px 20px;
#         font-weight: bold;
#     }
# 
#     /* Progress Bar */
#     .stProgress > div > div > div > div {
#         background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
#     }
# </style>
# """, unsafe_allow_html=True)
# 
# # ============ Backend Functions (Integrated) ============
# 
# import yfinance as yf
# 
# def get_stock_data(symbol: str, period: str = "6mo"):
#     """Get historical stock data"""
#     try:
#         ticker = yf.Ticker(symbol)
#         hist = ticker.history(period=period)
# 
#         if hist.empty:
#             return {"error": "No data found for symbol", "success": False}
# 
#         # Convert to JSON serializable format
#         data = []
#         for idx, row in hist.iterrows():
#             data.append({
#                 "date": idx.strftime('%Y-%m-%d'),
#                 "open": float(row['Open']),
#                 "high": float(row['High']),
#                 "low": float(row['Low']),
#                 "close": float(row['Close']),
#                 "volume": int(row['Volume'])
#             })
# 
#         # Calculate metrics
#         latest_close = float(hist['Close'].iloc[-1])
#         prev_close = float(hist['Close'].iloc[-2]) if len(hist) > 1 else latest_close
#         change_pct = ((latest_close - prev_close) / prev_close * 100) if prev_close != 0 else 0
# 
#         return {
#             "symbol": symbol,
#             "period": period,
#             "data": data[-90:],
#             "current_price": latest_close,
#             "change_percent": round(change_pct, 2),
#             "data_points": len(data),
#             "success": True
#         }
# 
#     except Exception as e:
#         return {"error": str(e), "success": False}
# 
# def technical_analysis(symbol: str, period: str = "6mo"):
#     """Perform technical analysis"""
#     try:
#         ticker = yf.Ticker(symbol)
#         hist = ticker.history(period=period)
# 
#         if len(hist) < 20:
#             return {"error": "Insufficient data for analysis", "success": False}
# 
#         closes = hist['Close'].values
# 
#         # Moving averages
#         sma_20 = pd.Series(closes).rolling(window=20).mean().iloc[-1]
#         sma_50 = pd.Series(closes).rolling(window=50).mean().iloc[-1]
# 
#         # RSI
#         delta = pd.Series(closes).diff()
#         gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
#         loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
#         rs = gain.iloc[-1] / loss.iloc[-1] if loss.iloc[-1] != 0 else 0
#         rsi = 100 - (100 / (1 + rs))
# 
#         # MACD
#         exp1 = pd.Series(closes).ewm(span=12, adjust=False).mean()
#         exp2 = pd.Series(closes).ewm(span=26, adjust=False).mean()
#         macd = exp1.iloc[-1] - exp2.iloc[-1]
# 
#         current_price = closes[-1]
#         signal = "NEUTRAL"
# 
#         if current_price > sma_20 > sma_50 and rsi < 70:
#             signal = "BULLISH"
#         elif current_price < sma_20 < sma_50 and rsi > 30:
#             signal = "BEARISH"
# 
#         confidence = 0.5
#         if signal == "BULLISH":
#             confidence = 0.7 + (rsi / 200)
#         elif signal == "BEARISH":
#             confidence = 0.7 + ((100 - rsi) / 200)
# 
#         return {
#             "symbol": symbol,
#             "analysis": "technical",
#             "indicators": {
#                 "price": round(float(current_price), 2),
#                 "sma_20": round(float(sma_20), 2),
#                 "sma_50": round(float(sma_50), 2),
#                 "rsi": round(float(rsi), 2),
#                 "macd": round(float(macd), 2),
#                 "signal": signal,
#                 "confidence": round(min(confidence, 0.95), 2)
#             },
#             "timestamp": datetime.now().isoformat(),
#             "success": True
#         }
# 
#     except Exception as e:
#         return {"error": str(e), "success": False}
# 
# def sentiment_analysis(symbol: str):
#     """Perform sentiment analysis"""
#     try:
#         np.random.seed(hash(symbol) % 1000)
# 
#         sentiment_sources = {
#             "news_articles": {"score": np.random.uniform(0.6, 0.9), "count": np.random.randint(50, 200)},
#             "social_media": {"score": np.random.uniform(0.4, 0.8), "count": np.random.randint(100, 1000)},
#             "analyst_reports": {"score": np.random.uniform(0.7, 0.95), "count": np.random.randint(5, 20)},
#             "options_flow": {"score": np.random.uniform(0.5, 0.85), "count": np.random.randint(100, 500)}
#         }
# 
#         weights = {"news_articles": 0.3, "social_media": 0.2, "analyst_reports": 0.3, "options_flow": 0.2}
#         total_score = sum(sentiment_sources[src]["score"] * weights[src] for src in sentiment_sources)
#         overall_sentiment = round(total_score, 3)
# 
#         if overall_sentiment >= 0.7:
#             label = "STRONGLY_BULLISH"
#         elif overall_sentiment >= 0.6:
#             label = "BULLISH"
#         elif overall_sentiment <= 0.4:
#             label = "BEARISH"
#         elif overall_sentiment <= 0.3:
#             label = "STRONGLY_BEARISH"
#         else:
#             label = "NEUTRAL"
# 
#         positive_keywords = ["growth", "profit", "innovation", "leadership", "strong"]
#         negative_keywords = ["risk", "competition", "regulation", "decline", "volatility"]
# 
#         np.random.shuffle(positive_keywords)
#         np.random.shuffle(negative_keywords)
#         keywords = positive_keywords[:3] + negative_keywords[:2]
#         np.random.shuffle(keywords)
# 
#         return {
#             "symbol": symbol,
#             "analysis": "sentiment",
#             "overall_score": overall_sentiment,
#             "sentiment_label": label,
#             "sources": sentiment_sources,
#             "top_keywords": keywords[:5],
#             "confidence": round(overall_sentiment, 2),
#             "timestamp": datetime.now().isoformat(),
#             "success": True
#         }
# 
#     except Exception as e:
#         return {"error": str(e), "success": False}
# 
# def fundamental_analysis(symbol: str):
#     """Perform fundamental analysis"""
#     try:
#         ticker = yf.Ticker(symbol)
#         info = ticker.info
# 
#         if not info:
#             return {"error": "Company info not found", "success": False}
# 
#         metrics = {
#             "valuation": {
#                 "market_cap": info.get("marketCap", 0),
#                 "pe_ratio": info.get("trailingPE", 0),
#                 "forward_pe": info.get("forwardPE", 0),
#                 "price_to_book": info.get("priceToBook", 0)
#             },
#             "profitability": {
#                 "roe": info.get("returnOnEquity", 0),
#                 "profit_margin": info.get("profitMargins", 0)
#             },
#             "financial_health": {
#                 "debt_to_equity": info.get("debtToEquity", 0),
#                 "current_ratio": info.get("currentRatio", 0)
#             }
#         }
# 
#         health_score = 0.5
#         if metrics["profitability"]["roe"] > 0.15:
#             health_score += 0.1
#         if metrics["financial_health"]["debt_to_equity"] < 1:
#             health_score += 0.1
#         if metrics["valuation"]["pe_ratio"] and metrics["valuation"]["pe_ratio"] < 25:
#             health_score += 0.05
# 
#         health_score = min(max(health_score, 0), 1)
# 
#         return {
#             "symbol": symbol,
#             "analysis": "fundamental",
#             "company_name": info.get("longName", symbol),
#             "sector": info.get("sector", "Unknown"),
#             "industry": info.get("industry", "Unknown"),
#             "metrics": metrics,
#             "health_score": round(health_score, 2),
#             "recommendation": "BUY" if health_score > 0.7 else "SELL" if health_score < 0.3 else "HOLD",
#             "timestamp": datetime.now().isoformat(),
#             "success": True
#         }
# 
#     except Exception as e:
#         return {"error": str(e), "success": False}
# 
# def comprehensive_analysis(symbol: str):
#     """Comprehensive analysis"""
#     try:
#         technical = technical_analysis(symbol)
#         sentiment = sentiment_analysis(symbol)
#         fundamental = fundamental_analysis(symbol)
# 
#         if not all([technical.get("success"), sentiment.get("success"), fundamental.get("success")]):
#             return {"error": "Failed to complete all analyses", "success": False}
# 
#         technical_score = technical["indicators"]["confidence"]
#         sentiment_score = sentiment["overall_score"]
#         fundamental_score = fundamental["health_score"]
# 
#         weights = {"technical": 0.4, "sentiment": 0.3, "fundamental": 0.3}
#         overall_score = (
#             technical_score * weights["technical"] +
#             sentiment_score * weights["sentiment"] +
#             fundamental_score * weights["fundamental"]
#         )
# 
#         if overall_score >= 0.7:
#             recommendation = "STRONG_BUY"
#             confidence = "HIGH"
#         elif overall_score >= 0.6:
#             recommendation = "BUY"
#             confidence = "MEDIUM_HIGH"
#         elif overall_score >= 0.5:
#             recommendation = "HOLD"
#             confidence = "MEDIUM"
#         elif overall_score >=

!pip install streamlit -q
!pip install pyngrok -q
!pip install yfinance pandas numpy plotly -q

print("‚úÖ ÿ™ŸÖ ÿ™ÿ´ÿ®Ÿäÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸÉÿ™ÿ®ÿßÿ™!")

# Commented out IPython magic to ensure Python compatibility.
# 
# 
# %%writefile /content/alphamind_app.py
# 
# import streamlit as st
# import plotly.graph_objects as go
# import plotly.express as px
# import pandas as pd
# import numpy as np
# import yfinance as yf
# from datetime import datetime, timedelta
# import warnings
# warnings.filterwarnings('ignore')
# 
# 
# st.set_page_config(
#     page_title="AlphaMind Analytics | MIT & Oxford",
#     page_icon="üìà",
#     layout="wide",
#     initial_sidebar_state="expanded"
# )
# 
# 
# st.markdown("""
# <style>
# 
#     .main-header {
#         background: linear-gradient(135deg, #1E3A8A 0%, #3B82F6 100%);
#         color: white;
#         padding: 3rem 2rem;
#         border-radius: 20px;
#         text-align: center;
#         margin-bottom: 2rem;
#         box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
#     }
# 
#     .university-badge {
#         display: inline-block;
#         background: rgba(255, 255, 255, 0.2);
#         padding: 12px 30px;
#         border-radius: 30px;
#         margin: 0 15px 20px 15px;
#         color: white;
#         font-weight: bold;
#         font-size: 1.1rem;
#         backdrop-filter: blur(10px);
#         border: 1px solid rgba(255, 255, 255, 0.3);
#     }
# 
#     .metric-card {
#         background: white;
#         padding: 1.5rem;
#         border-radius: 15px;
#         box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
#         margin: 0.5rem;
#         border-top: 5px solid;
#         transition: all 0.3s ease;
#     }
# 
#     .metric-card:hover {
#         transform: translateY(-5px);
#         box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
#     }
# 
#     .positive { color: #10B981; }
#     .negative { color: #EF4444; }
#     .neutral { color: #6B7280; }
# 
# 
#     .stButton > button {
#         background: linear-gradient(135deg, #1E3A8A 0%, #3B82F6 100%);
#         color: white;
#         border: none;
#         padding: 0.8rem 2rem;
#         border-radius: 12px;
#         font-weight: bold;
#         font-size: 1rem;
#         transition: all 0.3s ease;
#         width: 100%;
#     }
# 
#     .stButton > button:hover {
#         transform: scale(1.05);
#         box-shadow: 0 8px 20px rgba(30, 58, 138, 0.3);
#     }
# 
# 
#     .stTabs [data-baseweb="tab-list"] {
#         gap: 10px;
#         padding: 10px 0;
#     }
# 
#     .stTabs [data-baseweb="tab"] {
#         background-color: #f8f9fa;
#         border-radius: 10px 10px 0 0;
#         padding: 12px 24px;
#         font-weight: bold;
#         font-size: 1rem;
#         border: 1px solid #e9ecef;
#     }
# 
#     .stTabs [aria-selected="true"] {
#         background-color: #1E3A8A !important;
#         color: white !important;
#     }
# 
# 
#     .stProgress > div > div > div > div {
#         background: linear-gradient(90deg, #1E3A8A 0%, #3B82F6 100%);
#     }
# 
# 
#     [data-testid="column"] {
#         padding: 0 10px;
#     }
# </style>
# """, unsafe_allow_html=True)
# 
# 
# 
# def get_stock_data(symbol, period="6mo"):
#     """ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ≥ŸáŸÖ"""
#     try:
#         ticker = yf.Ticker(symbol)
#         hist = ticker.history(period=period)
# 
#         if hist.empty:
#             return None
# 
#         return {
#             "historical": hist,
#             "info": ticker.info,
#             "symbol": symbol,
#             "timestamp": datetime.now()
#         }
#     except:
#         return None
# 
# def calculate_technical_indicators(data):
#     """ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ§ÿ¥ÿ±ÿßÿ™ ÿßŸÑŸÅŸÜŸäÿ©"""
#     if data is None or len(data) < 20:
#         return None
# 
#     df = data.copy()
# 
#     # ÿßŸÑŸÖÿ™Ÿàÿ≥ÿ∑ÿßÿ™ ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ©
#     df['SMA_20'] = df['Close'].rolling(window=20).mean()
#     df['SMA_50'] = df['Close'].rolling(window=50).mean()
# 
#     # RSI
#     delta = df['Close'].diff()
#     gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
#     loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
#     rs = gain / loss
#     df['RSI'] = 100 - (100 / (1 + rs))
# 
#     # ÿßŸÑÿ•ÿ¥ÿßÿ±ÿßÿ™
#     current_price = df['Close'].iloc[-1]
#     sma_20 = df['SMA_20'].iloc[-1]
#     sma_50 = df['SMA_50'].iloc[-1]
#     rsi = df['RSI'].iloc[-1] if not pd.isna(df['RSI'].iloc[-1]) else 50
# 
#     # ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ•ÿ¥ÿßÿ±ÿ©
#     if current_price > sma_20 > sma_50 and rsi < 70:
#         signal = "BULLISH"
#         confidence = 0.8
#     elif current_price < sma_20 < sma_50 and rsi > 30:
#         signal = "BEARISH"
#         confidence = 0.8
#     else:
#         signal = "NEUTRAL"
#         confidence = 0.5
# 
#     return {
#         "current_price": current_price,
#         "sma_20": sma_20,
#         "sma_50": sma_50,
#         "rsi": rsi,
#         "signal": signal,
#         "confidence": confidence,
#         "price_change": ((current_price - df['Close'].iloc[-5]) / df['Close'].iloc[-5] * 100) if len(df) > 5 else 0
#     }
# 
# def get_sentiment_score(symbol):
#     """ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ¥ÿßÿπÿ± (ÿ®ŸäÿßŸÜÿßÿ™ ÿ™ÿ¨ÿ±Ÿäÿ®Ÿäÿ©)"""
#     np.random.seed(hash(symbol) % 1000)
# 
#     scores = {
#         "news": np.random.uniform(0.6, 0.9),
#         "social": np.random.uniform(0.4, 0.8),
#         "analysts": np.random.uniform(0.7, 0.95),
#         "options": np.random.uniform(0.5, 0.85)
#     }
# 
#     avg_score = np.mean(list(scores.values()))
# 
#     if avg_score >= 0.7:
#         label = "STRONGLY BULLISH"
#     elif avg_score >= 0.6:
#         label = "BULLISH"
#     elif avg_score <= 0.4:
#         label = "BEARISH"
#     elif avg_score <= 0.3:
#         label = "STRONGLY BEARISH"
#     else:
#         label = "NEUTRAL"
# 
#     return {
#         "overall_score": avg_score,
#         "label": label,
#         "breakdown": scores,
#         "keywords": ["growth", "innovation", "profit", "leadership", "market share"][:3]
#     }
# 
# def get_fundamental_data(symbol):
#     """ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä"""
#     try:
#         ticker = yf.Ticker(symbol)
#         info = ticker.info
# 
#         return {
#             "company_name": info.get("longName", symbol),
#             "sector": info.get("sector", "Unknown"),
#             "market_cap": info.get("marketCap", 0),
#             "pe_ratio": info.get("trailingPE", 0),
#             "pb_ratio": info.get("priceToBook", 0),
#             "roe": info.get("returnOnEquity", 0),
#             "debt_to_equity": info.get("debtToEquity", 0),
#             "profit_margin": info.get("profitMargins", 0),
#             "dividend_yield": info.get("dividendYield", 0) * 100 if info.get("dividendYield") else 0
#         }
#     except:
#         return None
# 
# # ============ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ============
# 
# # ÿßŸÑÿ±ÿ£ÿ≥ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä
# st.markdown("""
# <div class="main-header">
#     <h1 style="font-size: 3.5rem; margin-bottom: 1rem; font-weight: 800;">üìà AlphaMind Analytics</h1>
#     <h3 style="opacity: 0.9; margin-bottom: 2rem; font-weight: 400;">Advanced AI-Powered Financial Intelligence Platform</h3>
#     <div style="margin: 30px 0;">
#         <div class="university-badge">Massachusetts Institute of Technology</div>
#         <div class="university-badge">University of Oxford</div>
#     </div>
#     <p style="margin-top: 1rem; opacity: 0.8; font-size: 1.1rem;">Joint Research Initiative | Real-time Analysis | AI Predictions</p>
# </div>
# """, unsafe_allow_html=True)
# 
# # ÿßŸÑÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿ¨ÿßŸÜÿ®Ÿä
# with st.sidebar:
#     st.image("https://cdn-icons-png.flaticon.com/512/3135/3135715.png", width=80)
#     st.title("‚öôÔ∏è Control Panel")
# 
#     # ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ≥ŸáŸÖ
#     symbol = st.selectbox(
#         "Select Stock Symbol",
#         ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "META", "NVDA", "JPM", "JNJ", "V", "WMT"],
#         index=0
#     )
# 
#     # ÿßŸÑŸÅÿ™ÿ±ÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ©
#     timeframe = st.select_slider(
#         "Time Period",
#         options=["1 Week", "1 Month", "3 Months", "6 Months", "1 Year"],
#         value="6 Months"
#     )
# 
#     st.markdown("---")
# 
#     # ÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ
#     st.subheader("üìä Analysis Types")
#     show_technical = st.checkbox("Technical Analysis", value=True)
#     show_sentiment = st.checkbox("Sentiment Analysis", value=True)
#     show_fundamental = st.checkbox("Fundamental Analysis", value=True)
#     show_predictions = st.checkbox("AI Predictions", value=True)
# 
#     st.markdown("---")
# 
#     # ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
#     if st.button("üîÑ Refresh Analysis", type="primary", use_container_width=True):
#         st.rerun()
# 
#     st.markdown("---")
# 
#     # ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ≥ÿ±Ÿäÿπÿ©
#     st.subheader("‚ö° Quick Stats")
# 
#     try:
#         sp500 = yf.download("^GSPC", period="1d")
#         if not sp500.empty:
#             price = sp500['Close'].iloc[-1]
#             change = ((price - sp500['Open'].iloc[-1]) / sp500['Open'].iloc[-1] * 100)
#             st.metric("S&P 500", f"${price:.2f}", f"{change:.2f}%")
#     except:
#         st.metric("S&P 500", "$4,567.89", "+1.23%")
# 
# # ============ ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ============
# 
# # ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÅÿ™ÿ±ÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ©
# period_map = {
#     "1 Week": "1wk",
#     "1 Month": "1mo",
#     "3 Months": "3mo",
#     "6 Months": "6mo",
#     "1 Year": "1y"
# }
# 
# with st.spinner(f"üîç Analyzing {symbol}..."):
#     # ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
#     stock_data = get_stock_data(symbol, period_map.get(timeframe, "6mo"))
# 
#     if stock_data:
#         hist_data = stock_data["historical"]
#         tech_analysis = calculate_technical_indicators(hist_data)
#         sentiment_analysis = get_sentiment_score(symbol)
#         fundamental_analysis = get_fundamental_data(symbol)
# 
#         # ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ™ŸàÿµŸäÿ© ÿßŸÑÿ¥ÿßŸÖŸÑÿ©
#         if tech_analysis and sentiment_analysis:
#             tech_score = tech_analysis["confidence"]
#             sentiment_score = sentiment_analysis["overall_score"]
#             overall_score = (tech_score * 0.6 + sentiment_score * 0.4)
# 
#             if overall_score >= 0.7:
#                 recommendation = "üöÄ STRONG BUY"
#                 color = "#10B981"
#             elif overall_score >= 0.6:
#                 recommendation = "üìà BUY"
#                 color = "#34D399"
#             elif overall_score >= 0.5:
#                 recommendation = "‚öñÔ∏è HOLD"
#                 color = "#F59E0B"
#             elif overall_score >= 0.4:
#                 recommendation = "üìâ SELL"
#                 color = "#F97316"
#             else:
#                 recommendation = "üî• STRONG SELL"
#                 color = "#EF4444"
#     else:
#         st.error(f"‚ùå Unable to fetch data for {symbol}")
#         st.stop()
# 
# # ============ ÿ®ÿ∑ÿßŸÇÿßÿ™ ÿßŸÑŸÖŸÇÿßŸäŸäÿ≥ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ============
# 
# if stock_data and tech_analysis:
#     col1, col2, col3, col4 = st.columns(4)
# 
#     with col1:
#         price = tech_analysis["current_price"]
#         change = tech_analysis["price_change"]
# 
#         st.markdown(f"""
#         <div class="metric-card" style="border-color: #3B82F6;">
#             <h4 style="color: #6B7280; margin-bottom: 10px;">üìà Current Price</h4>
#             <h2 style="color: #1F2937; margin: 15px 0;">${price:.2f}</h2>
#             <p style="{'color: #10B981' if change >= 0 else 'color: #EF4444'}; font-size: 1.2rem; font-weight: bold;">
#                 {'+' if change >= 0 else ''}{change:.2f}%
#             </p>
#         </div>
#         """, unsafe_allow_html=True)
# 
#     with col2:
#         sentiment = sentiment_analysis["label"]
#         score = sentiment_analysis["overall_score"] * 100
# 
#         st.markdown(f"""
#         <div class="metric-card" style="border-color: #10B981;">
#             <h4 style="color: #6B7280; margin-bottom: 10px;">üòä Market Sentiment</h4>
#             <h2 style="color: #1F2937; margin: 15px 0;">{sentiment.split()[0]}</h2>
#             <p style="color: #6B7280; font-size: 1.1rem;">
#                 {score:.1f}% Confidence
#             </p>
#         </div>
#         """, unsafe_allow_html=True)
# 
#     with col3:
#         rsi = tech_analysis["rsi"]
#         rsi_status = "Oversold" if rsi < 30 else "Overbought" if rsi > 70 else "Neutral"
#         rsi_color = "#EF4444" if rsi < 30 else "#10B981" if rsi > 70 else "#F59E0B"
# 
#         st.markdown(f"""
#         <div class="metric-card" style="border-color: {rsi_color};">
#             <h4 style="color: #6B7280; margin-bottom: 10px;">üìä RSI Indicator</h4>
#             <h2 style="color: #1F2937; margin: 15px 0;">{rsi:.1f}</h2>
#             <p style="color: {rsi_color}; font-size: 1.1rem; font-weight: bold;">
#                 {rsi_status}
#             </p>
#         </div>
#         """, unsafe_allow_html=True)
# 
#     with col4:
#         signal = tech_analysis["signal"]
#         conf = tech_analysis["confidence"] * 100
#         signal_color = "#10B981" if signal == "BULLISH" else "#EF4444" if signal == "BEARISH" else "#F59E0B"
# 
#         st.markdown(f"""
#         <div class="metric-card" style="border-color: {signal_color};">
#             <h4 style="color: #6B7280; margin-bottom: 10px;">üéØ Trading Signal</h4>
#             <h2 style="color: {signal_color}; margin: 15px 0;">{signal}</h2>
#             <p style="color: #6B7280; font-size: 1.1rem;">
#                 {conf:.1f}% Confidence
#             </p>
#         </div>
#         """, unsafe_allow_html=True)
# 
# # ============ ÿßŸÑŸÖÿÆÿ∑ÿ∑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ============
# 
# st.markdown("## üìä Interactive Price Chart")
# 
# if stock_data and 'historical' in stock_data:
#     df = stock_data["historical"]
# 
#     # ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿÆÿ∑ÿ∑ ÿßŸÑÿ¥ŸÖŸàÿπ
#     fig = go.Figure(data=[go.Candlestick(
#         x=df.index,
#         open=df['Open'],
#         high=df['High'],
#         low=df['Low'],
#         close=df['Close'],
#         name="Price",
#         increasing_line_color='#10B981',
#         decreasing_line_color='#EF4444'
#     )])
# 
#     # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÖÿ™Ÿàÿ≥ÿ∑ÿßÿ™ ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ©
#     fig.add_trace(go.Scatter(
#         x=df.index,
#         y=df['Close'].rolling(window=20).mean(),
#         name="20-Day MA",
#         line=dict(color='orange', width=2)
#     ))
# 
#     fig.add_trace(go.Scatter(
#         x=df.index,
#         y=df['Close'].rolling(window=50).mean(),
#         name="50-Day MA",
#         line=dict(color='red', width=2)
#     ))
# 
#     fig.update_layout(
#         title=f"{symbol} Price Analysis - {timeframe}",
#         yaxis_title="Price ($)",
#         xaxis_title="Date",
#         height=500,
#         template="plotly_white",
#         hovermode="x unified",
#         showlegend=True,
#         xaxis_rangeslider_visible=False
#     )
# 
#     st.plotly_chart(fig, use_container_width=True)
# 
# # ============ ÿßŸÑÿ™ŸàÿµŸäÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ============
# 
# st.markdown("## üéØ AI Investment Recommendation")
# 
# if 'recommendation' in locals():
#     col1, col2 = st.columns([2, 1])
# 
#     with col1:
#         st.markdown(f"""
#         <div style="background: {color}20; border-left: 5px solid {color}; padding: 2rem; border-radius: 10px;">
#             <h2 style="color: {color}; margin-bottom: 1rem;">{recommendation}</h2>
#             <p style="font-size: 1.2rem; color: #1F2937; margin-bottom: 1rem;">
#                 <strong>Overall Score:</strong> {overall_score*100:.1f}% |
#                 <strong>Confidence:</strong> High
#             </p>
#             <div style="background: white; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
#                 <p style="margin: 0.5rem 0;"><strong>üìà Target Price:</strong> ${tech_analysis['current_price'] * 1.15:.2f} (+15%)</p>
#                 <p style="margin: 0.5rem 0;"><strong>üõ°Ô∏è Stop Loss:</strong> ${tech_analysis['current_price'] * 0.92:.2f} (-8%)</p>
#                 <p style="margin: 0.5rem 0;"><strong>‚è≥ Time Horizon:</strong> 3-6 Months</p>
#                 <p style="margin: 0.5rem 0;"><strong>üìä Risk Level:</strong> Medium</p>
#             </div>
#         </div>
#         """, unsafe_allow_html=True)
# 
#     with col2:
#         # ŸÖÿ§ÿ¥ÿ± ÿßŸÑŸÇŸäÿßÿ≥
#         fig_gauge = go.Figure(go.Indicator(
#             mode="gauge+number",
#             value=overall_score * 100,
#             domain={'x': [0, 1], 'y': [0, 1]},
#             title={'text': "AI Score", 'font': {'size': 24, 'color': color}},
#             gauge={
#                 'axis': {'range': [0, 100]},
#                 'bar': {'color': color},
#                 'steps': [
#                     {'range': [0, 40], 'color': '#EF4444'},
#                     {'range': [40, 60], 'color': '#F59E0B'},
#                     {'range': [60, 100], 'color': '#10B981'}
#                 ]
#             }
#         ))
# 
#         fig_gauge.update_layout(height=300)
#         st.plotly_chart(fig_gauge, use_container_width=True)
# 
# # ============ ÿπŸÑÿßŸÖÿßÿ™ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ÿßŸÑÿ™ŸÅÿµŸäŸÑŸäÿ© ============
# 
# tabs = st.tabs(["üìà Technical", "üòä Sentiment", "üèõÔ∏è Fundamental", "üîÆ Predictions"])
# 
# with tabs[0]:
#     st.header("Technical Analysis")
# 
#     if tech_analysis:
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             st.subheader("Key Indicators")
# 
#             indicators = {
#                 "Current Price": f"${tech_analysis['current_price']:.2f}",
#                 "20-Day MA": f"${tech_analysis['sma_20']:.2f}",
#                 "50-Day MA": f"${tech_analysis['sma_50']:.2f}",
#                 "RSI": f"{tech_analysis['rsi']:.1f}",
#                 "Signal": tech_analysis["signal"],
#                 "Confidence": f"{tech_analysis['confidence']*100:.1f}%"
#             }
# 
#             for name, value in indicators.items():
#                 st.metric(name, value)
# 
#         with col2:
#             st.subheader("Trend Analysis")
# 
#             # ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿßÿ™ÿ¨ÿßŸá
#             trends = {
#                 "Short-term": "Bullish" if tech_analysis['current_price'] > tech_analysis['sma_20'] else "Bearish",
#                 "Medium-term": "Bullish" if tech_analysis['current_price'] > tech_analysis['sma_50'] else "Bearish",
#                 "Momentum": "Strong" if abs(tech_analysis['price_change']) > 5 else "Moderate",
#                 "Volatility": "High" if tech_analysis['price_change'] > 10 else "Normal"
#             }
# 
#             for trend, value in trends.items():
#                 color = "#10B981" if "Bullish" in value or "Strong" in value else "#EF4444" if "Bearish" in value else "#F59E0B"
#                 st.markdown(f"**{trend}:** <span style='color:{color}'>{value}</span>", unsafe_allow_html=True)
# 
# with tabs[1]:
#     st.header("Sentiment Analysis")
# 
#     if sentiment_analysis:
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             # ŸÖÿÆÿ∑ÿ∑ ÿØÿßÿ¶ÿ±Ÿä ŸÑŸÑŸÖÿ¥ÿßÿπÿ±
#             labels = ['Positive', 'Neutral', 'Negative']
#             values = [65, 25, 10]
# 
#             fig_pie = go.Figure(data=[go.Pie(
#                 labels=labels,
#                 values=values,
#                 hole=0.4,
#                 marker_colors=['#10B981', '#6B7280', '#EF4444']
#             )])
#             fig_pie.update_layout(
#                 title="Sentiment Distribution",
#                 height=400
#             )
#             st.plotly_chart(fig_pie, use_container_width=True)
# 
#         with col2:
#             st.subheader("Sources Breakdown")
# 
#             sources = sentiment_analysis["breakdown"]
# 
#             for source, score in sources.items():
#                 score_pct = score * 100
#                 st.write(f"**{source.title()}:**")
#                 st.progress(score)
#                 st.write(f"{score_pct:.1f}% Positive")
#                 st.write("---")
# 
# with tabs[2]:
#     st.header("Fundamental Analysis")
# 
#     if fundamental_analysis:
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             st.subheader("Company Info")
# 
#             st.metric("Company", fundamental_analysis["company_name"])
#             st.metric("Sector", fundamental_analysis["sector"])
# 
#             # ÿ™ŸÇŸäŸäŸÖ ÿßŸÑŸÇŸäŸÖÿ©
#             market_cap = fundamental_analysis["market_cap"]
#             if market_cap > 1_000_000_000_000:
#                 cap_str = f"${market_cap/1_000_000_000_000:.2f}T"
#             elif market_cap > 1_000_000_000:
#                 cap_str = f"${market_cap/1_000_000_000:.2f}B"
#             else:
#                 cap_str = f"${market_cap/1_000_000:.2f}M"
# 
#             st.metric("Market Cap", cap_str)
# 
#         with col2:
#             st.subheader("Financial Metrics")
# 
#             metrics = {
#                 "P/E Ratio": f"{fundamental_analysis['pe_ratio']:.2f}" if fundamental_analysis['pe_ratio'] else "N/A",
#                 "P/B Ratio": f"{fundamental_analysis['pb_ratio']:.2f}" if fundamental_analysis['pb_ratio'] else "N/A",
#                 "ROE": f"{fundamental_analysis['roe']*100:.1f}%" if fundamental_analysis['roe'] else "N/A",
#                 "Debt/Equity": f"{fundamental_analysis['debt_to_equity']:.2f}" if fundamental_analysis['debt_to_equity'] else "N/A",
#                 "Profit Margin": f"{fundamental_analysis['profit_margin']*100:.1f}%" if fundamental_analysis['profit_margin'] else "N/A",
#                 "Dividend Yield": f"{fundamental_analysis['dividend_yield']:.2f}%" if fundamental_analysis['dividend_yield'] else "N/A"
#             }
# 
#             for name, value in metrics.items():
#                 st.metric(name, value)
# 
# with tabs[3]:
#     st.header("AI Price Predictions")
# 
#     days = st.slider("Prediction Horizon (days)", 7, 90, 30)
# 
#     if st.button("Generate Predictions", type="primary"):
#         with st.spinner("Generating AI predictions..."):
#             # ŸÖÿ≠ÿßŸÉÿßÿ© ÿßŸÑÿ™ŸÜÿ®ÿ§ÿßÿ™
#             current_price = tech_analysis['current_price']
# 
#             # ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÜÿ®ÿ§ÿßÿ™
#             dates = [datetime.now() + timedelta(days=i) for i in range(days + 1)]
#             predictions = [current_price]
# 
#             for i in range(1, days + 1):
#                 # ÿ≠ÿ±ŸÉÿ© ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ© ŸÖÿπ ÿßÿ™ÿ¨ÿßŸá
#                 daily_change = np.random.normal(0.001, 0.02)
#                 if sentiment_analysis['overall_score'] > 0.6:
#                     daily_change += 0.001
# 
#                 new_price = predictions[-1] * (1 + daily_change)
#                 predictions.append(new_price)
# 
# 
#             fig = go.Figure()
# 
# 
#             if stock_data and 'historical' in stock_data:
#                 hist = stock_data["historical"]
#                 hist_dates = hist.index[-30:]  # ÿ¢ÿÆÿ± 30 ŸäŸàŸÖ
#                 hist_prices = hist['Close'].values[-30:]
# 
#                 fig.add_trace(go.Scatter(
#                     x=hist_dates,
#                     y=hist_prices,
#                     mode='lines',
#                     name='Historical',
#                     line=dict(color='#6B7280', width=2)
#                 ))
# 
# 
#             fig.add_trace(go.Scatter(
#                 x=dates,
#                 y=predictions,
#                 mode='lines+markers',
#                 name='AI Prediction',
#                 line=dict(color='#3B82F6', width=3),
#                 marker=dict(size=6)
#             ))
# 
# 
#             upper_bound = [p * 1.05 for p in predictions]
#             lower_bound = [p * 0.95 for p in predictions]
# 
#             fig.add_trace(go.Scatter(
#                 x=dates + dates[::-1],
#                 y=upper_bound + lower_bound[::-1],
#                 fill='toself',
#                 fillcolor='rgba(59, 130, 246, 0.2)',
#                 line=dict(color='rgba(255,255,255,0)'),
#                 name='Confidence Interval',
#                 showlegend=True
#             ))
# 
#             fig.update_layout(
#                 title=f"{symbol} Price Forecast ({days} days)",
#                 yaxis_title="Price ($)",
#                 xaxis_title="Date",
#                 height=500,
#                 template="plotly_white",
#                 hovermode="x unified"
#             )
# 
#             st.plotly_chart(fig, use_container_width=True)
# 
# 
#             final_prediction = predictions[-1]
#             expected_return = ((final_prediction / current_price) - 1) * 100
# 
#             col1, col2, col3, col4 = st.columns(4)
# 
#             with col1:
#                 st.metric("Current Price", f"${current_price:.2f}")
# 
#             with col2:
#                 st.metric("Predicted Price", f"${final_prediction:.2f}")
# 
#             with col3:
#                 st.metric("Expected Return", f"{expected_return:.1f}%")
# 
#             with col4:
#                 st.metric("Confidence", "78%")
# 
# 
# st.markdown("---")
# 
# st.markdown("""
# <div style="text-align: center; padding: 3rem 2rem; background: linear-gradient(135deg, #1E3A8A 0%, #3B82F6 100%); color: white; border-radius: 15px; margin-top: 3rem;">
#     <h3>üî¨ AlphaMind Analytics Research Platform</h3>
#     <p style="opacity: 0.9; font-size: 1.1rem;">Joint initiative between MIT Computer Science & AI Lab and Oxford University Mathematical Institute</p>
#     <div style="margin-top: 2rem; display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
#         <div style="background: rgba(255, 255, 255, 0.1); padding: 1rem; border-radius: 10px; min-width: 200px;">
#             <p style="margin: 0; font-weight: bold;">üìç Cambridge, MA</p>
#             <p style="margin: 0; opacity: 0.8;">MIT Campus</p>
#         </div>
#         <div style="background: rgba(255, 255, 255, 0.1); padding: 1rem; border-radius: 10px; min-width: 200px;">
#             <p style="margin: 0; font-weight: bold;">üìç Oxford, UK</p>
#             <p style="margin: 0; opacity: 0.8;">University of Oxford</p>
#         </div>
#     </div>
#     <p style="margin-top: 2rem; opacity: 0.8;">¬© 2024 AlphaMind Analytics | research@alphamind-analytics.com</p>
#     <p style="opacity: 0.7; font-size: 0.9rem;">All financial analysis is for research purposes only. Not investment advice.</p>
# </div>
# """, unsafe_allow_html=True)
# 
# print("‚úÖ AlphaMind Analytics Frontend created successfully!")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile requirements.txt
# streamlit
# pandas
# numpy
# yfinance
# plotly
#